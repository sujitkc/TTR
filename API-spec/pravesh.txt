API SPECIFICATION
-----------------

--------------------------------------TYPES------------------------------
type Role = ADMIN | CANDIDATE | OFFICE | FACULTY
type Program { id : string, name : string}
type HTTPResponseCode = OK | NOTFOUND | ERROR
------------------------------------------------------------------------

------------------------------------GLOBAL DATA-----------------------------
U : (string -> string) map
L : string set
T : (Token -> string) map
P : Program
PermittedRoleCombinations : Role set set =
{
	{ ADMIN, FACULTY, DOMAIN_REP, COMITTEE },
⁠	{ CANDIDATE, OFFICE, ADMIN },
⁠	{ CANDIDATE },
}
------------------------------------------------------------------------

------------------------------------APIs------------------------------------
signup: string * string ==> HTTPResponseCode
login:  string * string ==> (HTTPResponseCode * token)
createProgram: Token * string ==> (HTTPResponseCode * string)
------------------------------------------------------------------------

---------------------------------INITIALISATION-----------------------------
INIT:
U = {}
L = {}
T = {}
P = {}
-------------------------------------------------------------------------------------------------------------------------------------------------------------------

---------------------------------SIGNUP_OK-----------------------------------
PRECONDITION: U[uid] = NIL
signup(uid, p) ==> (OK)
POSTCONDITION: U' = U[uid -> p]
------------------------------------------------------------------------

---------------------------------LOGIN_OK-----------------------------------
PRECONDITION: U[uid] = p
login(uid, p) ==> (OK, t)
POSTCONDITION: T' = T[t -> uid] AND L' = L union {uid}
------------------------------------------------------------------------

-------------------------------CREATEPROGRAM_OK-----------------------------
PRECONDITION: 
(t -> u in T and u in U) AND (role = ADMIN) AND
(not_exists p in P s.t. p.name = programName)


createProgram(t, programName) ==> (OK, id)

POSTCONDITION: P' = P union Program{id, programName}
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
----------------------------SUBMIT_APPLICATION_OK-----------------------------------------------------------------------------------------------------------------------------------

Precondition:

t∈T and T[t]∈U (user is authenticated)

role = CANDIDATE (user role is candidate) 
not_existsa ∈ As.t.sa.candidateId=T[t](no exisiting application for the candidate) 

Specification :
submitApplication(t, programId) ==> (OK, applicationId)

Postcondition:

A ′ =A[a↦Application{id=applicationId,candidateId=T[t],programId=programId,status="SUBMITTED"}]

------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
----------------------------------UPDATE_PROGRAM_OK--------------------------------------------------------------------------------------------------------------------------------------

Precondition:

t∈T and T[t]∈U (user is authenticated)
role=ADMIN (user role is ADMIN)
existsp∈Ps.t.p.id=programId (program exists)

Specification:
updateProgram(t, programId, newProgramName) ==> OK

Postcondition:

P'=[programId].name=newProgramName
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------DELETE_PROGRAM_OK----------------------------------------------------------------------------------------------
Precondition:

t∈T and 
T[t]∈U (user is authenticated)

role=ADMIN (user role is ADMIN)
existsp∈Ps.t.p.id=programId (program exists)

Specification:
deleteProgram(t, programId) ==> OK

Postcondition:
P ′ =P∖{p∈Ps.t.p.id=programId}
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
1. Sign-Up: Negative Scenario
Scenario: A user tries to sign up, but they already have an account. This is the failure scenario where the API rejects the request.

Precondition:
The user ID uid already exists in the user map U.

PRECONDITION: U[uid] ≠ NIL
This precondition checks that the user ID uid is found in U, meaning the user has already signed up.

API Specification:
The user attempts to sign up again with their uid and password.

signup(uid, p) ==> ERROR

Since the precondition is not met (the user already exists), the API returns an error code (ERROR).

Postcondition:
The user map U remains unchanged because no new user was created.

POSTCONDITION: U' = U

Explanation:
This prevents duplicate registrations. If the user already exists, the system will not overwrite or create a new entry. The precondition checks for existence, and the postcondition ensures that no changes are made if the sign-up fails.


------------------------------------------

2.Login: Negative Scenario

Scenario: A user provides invalid credentials and fails to log in.

Precondition:
The user ID uid exists, but the password p does not match.

PRECONDITION: U[uid] ≠ p
This checks that the provided password p does not match the one stored for uid in U.

API Specification:
The user attempts to log in with incorrect credentials.

login(uid, p) ==> ERROR
The API returns ERROR because the credentials do not match.

Postcondition:
The token map T and the logged-in user set L remain unchanged.

POSTCONDITION: T' = T AND L' = L
No changes are made to the system because the login failed.

Explanation:
In this case, the system protects against unauthorized access. The precondition checks for incorrect credentials, and the postcondition ensures that no session is created for the invalid login attempt.


----------------------------------------------------------------------------------------------------------------------------------------------------

3. Logout: Positive Scenario
Scenario: A user who is currently logged in successfully logs out.

Precondition:
The user uid is currently logged in (i.e., their session token t is valid and exists in T).

PRECONDITION: t ∈ T AND T[t] = uid
This checks that the token t is valid and associated with the user uid.

API Specification:
The API takes the session token t as input.

logout(t) ==> OK
If the precondition is met, the API returns OK indicating successful logout.

Postcondition:
The session token t is removed from the map T, and the user ID uid is removed from the logged-in users set L.

POSTCONDITION: T' = T \ {t} AND L' = L \ {uid}
The token t and the user uid are removed from the system, meaning the user is no longer logged in.

Explanation:
In a successful logout, the precondition ensures that the user is already logged in, and the postcondition clears the session and logs the user out.

-------------------------------------------------------------------------------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------------------------------------------------------------------------------
ABSTRACT TEST CASE
------------------
Test case ID: A_createProgram_Success

reset
ASSUME(uid->p in U)
(rcode1, t) := login(uid, p)
ASSERT(rcode1 = OK)

ASSUME(not_exists prog in P s.t. prog.name = progname)
(rcode2, progid) := createProgram(t, progname)
ASSERT(rcode2 = OK)
(rcode3, data) := getProgram(t, progid)
ASSERT((rcode3 = OK) AND (data.id = progid) AND (data.name = progname))
------------------------------------------------------------------------
Successful Application Submission
Test Case ID: A_SubmitApplication_Success
Objective: Verify that a candidate can successfully submit an application for a program if they have not applied before.
Steps:
reset: Clear the state to start fresh.

Login Step:

ASSUME(uid->p in U)   - This assumption implies that the candidate account exists in the system, and we have a valid uid and p to proceed with the login attempt.
(rcode1, t) := login(uid, p)
ASSERT(rcode1 = OK)

Application Submission Step:

ASSUME(not_exists app in A s.t. app.candidateId = uid AND app.programId = progId)
(rcode2, appId) := submitApplication(t, progId, applicationData)
ASSERT(rcode2 = OK)

ASSUME: No application from uid for progId exists in A.
Action: Submit an application using the session token t, program ID progId, and applicationData.


Expected Result:
rcode2 = OK confirms the application submission was successful, and appId is returned as the unique application ID.
---------------------------------------------------------------------------------------------------------------------------------------------------------------
B) Abstract Test Case 2: Failed Login (Invalid Credentials)
Test Case ID: A_Login_Failure_InvalidPassword
Objective: Verify that login fails when a user provides an incorrect password.
Steps:
reset: Clear the system state for a clean environment.

Login Step:


ASSUME(uid->p in U)
(rcode1, t) := login(uid, "wrong_password")
ASSERT(rcode1 = ERROR)
ASSERT(t = NIL)
ASSUME: A user with identifier uid and correct password p exists in U.
Action: Attempt to log in with uid but use an incorrect password, "wrong_password".
Expected Result:
rcode1 = ERROR confirms the login failed.
t = NIL means no session token was issued since authentication was unsuccessful.

-----------------------------------------------------------------------------------------------------------------------------------------------------------------
C) Abstract Test Case 3: Successful Program Creation by Admin
Test Case ID: A_CreateProgram_Success
Objective: Verify that an admin can successfully create a program if it doesn’t already exist.
Steps:
reset: Ensure a clean start.

Login Step:
ASSUME(admin_uid->admin_pass in U)
(rcode1, t) := login(admin_uid, admin_pass)
ASSERT(rcode1 = OK)

Program Creation Step:

ASSUME(not_exists prog in P s.t. prog.name = progname)
(rcode2, progid) := createProgram(t, progname)
ASSERT(rcode2 = OK)
ASSUME: progname does not already exist in P.
Action: Call createProgram using the session token t and the name progname.
Expected Result:
rcode2 = OK confirms that the program was created successfully, and a unique program ID progid is returned.

Notes :
rcode1: This variable captures the response code 
t: This variable captures the session token generated if the login is successful.
-------------------------------------------------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------------------------------------------------
CONCRETE TEST CASE
------------------
Test case ID: C_createProgram_Success_1 (A_createProgram_Success)

reset
uid := "nikhilakn"
p := "nikhila"
(rcode1, t) := login(uid, p)
ASSERT(rcode1 = OK)
progname = 'someprog'
(rcode2, progid) := createProgram(t, progname)
ASSERT(rcode2 = OK)
(rcode3, data) := getProgram(t, progid)
ASSERT((rcode3 = OK) AND (data.id = progid) AND (data.name = progname))
