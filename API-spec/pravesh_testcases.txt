API SPECIFICATION
-----------------
GLOBAL DATA
-----------------
type Role = ADMIN | CANDIDATE | OFFICE | FACULTY | COMMITTEE | DOMAIN_REPRESENTATIVE
type Program { id : string, name : string }
type Domain{ id: string, programId: string, domainName: string}
type subDomain {id: string, domainId: string, subdomainName: string} 
type Application_status = VERIFICATION_PENDING|RELEASED_FOR_EVALUATION|EVALUATION_COMPLETED|SHORTLISTED|OFFERED
type Application { id: string, programId: string, domainId: string, subDomainId: string, status: Application_status, evalIds:[string] }
type Referral {id: string, appId: string, referrerId: string, referredIds: [string] }

type USERDATA{password: string, Applications: Application set, roles: Role set}

PermittedRoleCombinations : Role set set =
{
	{ ADMIN, FACULTY, DOMAIN_REP, COMITTEE },
⁠	{ CANDIDATE, OFFICE, ADMIN },
⁠	{ CANDIDATE },
	{ FACULTY },
}


U : (string -> string) map // Users
C : set of all u in U, s.t u.role = CANDIDATE
L : string set // Logged in users
T : (Token -> string) map // Tokens
P : Program set // Set of Programs
A : (C -> Application) map // Applications
F : set of all u in U, s.t u.role = FACULTY
E : A set of applications assigned to an individual's evaluation/referral list
D : Domain set // set of Domains
SD: Sub domain set // set of sub domains

Exists R in PermittedRoleCombinations | For all u in U, u.roles is subset of R

------------------------------------APIs------------------------------------
signup: string * string ==> HTTPRESPONSECODE
login:  string * string ==> (HTTPRESPONSECODE * token)

// Reset APIs
factoryReset: Token ==> HTTPRESPONSECODE	//This reset returns the system to its initial state with only the admin user present, and all data is wiped from the database.

resetWithSomeUsersAndApplications: Token ==> HTTPRESPONSECODE //This reset sets up the system with a specific set of users and applications. It includes a mix of verified and non-verified applications.

// Program APIs
createProgram: Token * string ==> (HTTPRESPONSECODE * string)
getProgram: Token * string ==> (HTTPRESPONSECODE * string)
editProgram: Token * string ==> (HTTPRESPONSECODE * string)
deleteProgram: Token * string ==> (HTTPRESPONSECODE)

// Domain APIs
createDomain: Token * string ==> (HTTPRESPONSECODE * string)
getDomain: Token * string ==> (HTTPRESPONSECODE * string)
editDomain: Token * string ==> (HTTPRESPONSECODE * string)
deleteDomain: Token * string ==> (HTTPRESPONSECODE)

// SubDomain APIs
createSubdomain: Token * string * string ==> (HTTPRESPONSECODE * string)
getSubdomain: Token * string ==> (HTTPRESPONSECODE * string)
editSubdomain: Token * string * string ==> (HTTPRESPONSECODE * string)
deleteSubdomain: Token * string ==> (HTTPRESPONSECODE)

// Application APIs
submitApplication: Token * string ==> (HTTPRESPONSECODE * string)
verifyApplication: Token * string ==> (HTTPRESPONSECODE)
getApplications: Token ==> (HTTPRESPONSECODE * Application set)
selectApplication: Token * string * string ==> (HTTPRESPONSECODE)
referApplication: Token * string * string ==> (HTTPRESPONSECODE)
evaluateApplication: Token * string * map ==> (HTTPRESPONSECODE)

---------------------------------INITIALISATION-----------------------------
INIT:
U = {}
T = {}
P = {}
A = {}
F = {}
E = {}
---------------------------------SYSTEM_RESETS------------------------------

----------------------------------------------------------------------------

---------------------------------SIGNUP_OK-----------------------------------
PRECONDITION: U[uid] = NIL
signup(uid : string, p : string) ==> (OK)
POSTCONDITION: U' = U[uid -> p]
-----------------------------------------------------------------------------

---------------------------------LOGIN_OK------------------------------------
PRECONDITION: U[uid] = p
login(uid : string, p : string) ==> (OK, t : token)
POSTCONDITION: T' = T[t -> uid]
-----------------------------------------------------------------------------

-------------------------------CREATEPROGRAM_OK------------------------------
PRECONDITION: 
(t -> u in T and u in U) AND (ADMIN in u.role) AND
(not_exists p in P s.t. p.name = programName)


createProgram(t : Token, programName : string) ==> (OK, id : string)

POSTCONDITION: P' = P union Program{id, programName}
-----------------------------------------------------------------------------
———————————————GETPROGRAM_OK-------------------------------------------------
PRECONDITION: 
(t -> u in T and u in U) AND (ADMIN in u.role) AND
( p in P s.t.  programId = p.id)


getProgram(t : Token, programName : string) ==> (OK, programData: Program)

POSTCONDITION: programId = programData.id
-----------------------------------------------------------------------------
———————————————UPDATEPROGRAM_OK----------------------------------------------
PRECONDITION: 
(t -> u in T and u in U) AND (ADMIN in u.role) AND
( p in P s.t.  programId = p.id) AND p.name = newProgramName


updateProgram(t : Token, newProgramName: string) ==> (OK, id : string)

POSTCONDITION: P' = P union Program{id, newprogramName}
------------------------------------------------------------------------

———————————————SUBMITAPPLICATION_OK-----------------------------
PRECONDITION: (t -> u in T AND u in U) AND (CANDIDATE in u.roles) AND
(not_exists app' in A[u] s.t. (app.domainId = app'.domainId AND app.subDomainId = app'.subDomainId AND app.programId = app'.programId))
submitApplication(t : Token, app : Application) ==> (OK, id: string)
POSTCONDITION: A' = A union Application{id, app.domainId, app.subDomainId, app.programId} 
------------------------------------------------------------------------
----------------FACULTYREFERAPPLICATION_OK------------------------------
PRECONDITION: (t -> u in T AND u in U) AND (FACULTY in u.roles) AND (app in A) AND (facultySet = sub set of F)
referApplication(t: Token, app.Id: string, facultySet: set of FACULTY) ==> (OK)
POSTCONDITION: E' = E union {Referral{id, appId, u.id, facultySet}}
-------------------------------------------------------------------------

-------------------CREATEDOMAIN_OK--------------------------------------
PRECONDITION: (t -> u in T AND u in U) AND (ADMIN in u.roles) AND (not_exists d in D s.t. d.name = domainName)
createDomain(t: Token, programId: string, domainName: string) ==> (OK, id: string)
POSTCONDITION: D’ = D union Domain{id, programId, domainName}
------------------------------------------------------------------------
-------------------GETDOMAIN_OK-----------------------------------------
PRECONDITION: (t -> u in T AND u in U)
getDomain(t: Token, domainId: string) ==> (OK, domainData: Domain)
POSTCONDITION: domainId = domainData.id
------------------------------------------------------------------------
-------------------EDITDOMAIN_OK---------------------------------------
PRECONDITION: (t -> u in T AND u in U) AND (ADMIN in u.roles) AND (exists d in D s.t. d.id = domainId)
editDomain(t: Token, domainId: string, newDomainName: string) ==> (OK)
POSTCONDITION: D’ = D union Domain{domainId, newDomainName}
------------------------------------------------------------------------
-------------------DELETEDOMAIN_OK-------------------------------------
PRECONDITION:(t -> u in T AND u in U) AND (ADMIN in u.roles) AND (exists d in D s.t. d.id = domainId)
deleteDomain(t: Token, domainId: string) ==> (OK)
POSTCONDITION: D’ = D \ {d | d.id = domainId}
------------------------------------------------------------------------

-------------------CREATESUBDOMAIN_OK------------------------------------

PRECONDITION: (t -> u in T AND u in U) AND (ADMIN in u.roles) AND (exists d in D s.t. d.id = domainId) AND (not_exists s in SD s.t. s.name = subdomainName)
createSubdomain(t: Token, domainId: string, subdomainName: string) ==> (OK, id: string)
POSTCONDITION: SD’ = SD union subDomain{id, subdomainName, domainId}
------------------------------------------------------------------------
-------------------GETSUBDOMAIN_OK------------------------------------

PRECONDITION: (t -> u in T AND u in U) AND (ADMIN in u.roles)
getSubdomain(t: Token, subdomainId: string) ==> (OK, subdomainData: Subdomain)
POSTCONDITION: subdomainId = subdomainData.id
------------------------------------------------------------------------
-------------------EDITSUBDOMAIN_OK--------------------------------------
PRECONDITION: (t -> u in T AND u in U) AND (ADMIN in u.roles) AND (exists s in SD s.t. s.id = subdomainId)
editSubdomain(t: Token, subdomainId: string, newSubdomainName: string) ==> (OK)
POSTCONDITION: SD’ = SD union subDomain{subdomainId, newSubdomainName, domainId}

------------------------------------------------------------------------
-----------------------DELETESUBDOMAIN_OK-------------------------------
PRECONDITION: (t -> u in T AND u in U) AND (ADMIN in u.roles) AND (exists s in SD s.t. s.id = subdomainId)
deleteSubdomain(t: Token, subdomainId: string) ==> (OK)
POSTCONDITION: SD’ = SD \ {s | s.id = subdomainId}
------------------------------------------------------------------------


ABSTRACT TEST CASE
------------------------------------------------------------------------
Test case ID: A_createProgram_Success

reset R1
ASSUME((uid->p in U) AND (ADMIN in u.role)) // assuming U is a map: string --> string
(rcode1, t) := login(uid, p)
ASSERT(rcode1 = OK)

ASSUME(not_exists prog in Programs s.t. prog.name = progname)
(rcode2, progid) := createProgram(t, progname)
ASSERT(rcode2 = OK)
------------------------------------------------------------------------
Test case ID: A_createAndGetProgram_Success

reset R1
ASSUME(uid->p in U) AND (ADMIN in u.role)) // assuming U is a map: string --> string
(rcode1, t) := login(uid, p)
ASSERT(rcode1 = OK)

ASSUME(not_exists prog in Programs s.t. prog.name = progname)
(rcode2, progid) := createProgram(t, progname)
ASSERT(rcode2 = OK)
(rcode3, data) := getProgram(t, progid)
ASSERT((rcode3 = OK) and (data.id = progid) and (data.name = progname))
------------------------------------------------------------------------
Test case ID: A_createProgramAndEdit_Success

reset R1
ASSUME((uid -> p in U) AND (ADMIN in u.role))
(rcode1, t) := login(uid, p)
ASSERT(rcode1 = OK)

ASSUME(not_exists prog in Programs s.t. prog.name = progName)
(rcode2, progid) := createProgram(t, progName)
ASSERT(rcode2 = OK)
newProgName := random.string
(rcode3, editedProgName) := editProgram(t, progid, newProgName)
ASSERT((rcode3 = OK) AND (editedProgName = newProgName))
(rcode4, programData) := getProgram(t, progid)
ASSERT((rcode4 = OK) AND (programData.id = progid) AND (programData.name = newProgName))

------------------------------------------------------------------------
Test case ID: A_createProgramAndDelete_Success

reset R1
ASSUME((uid -> p in U) AND (ADMIN in u.role))
(rcode1, t) := login(uid, p)
ASSERT(rcode1 = OK)

ASSUME(not_exists prog in Programs s.t. prog.name = progName)
(rcode2, progid) := createProgram(t, progName)
ASSERT(rcode2 = OK)
(rcode3) := deleteProgram(t, progid)
ASSERT(rcode3 = OK)
(rcode4, programData) := getProgram(t, progid)
ASSERT((rcode4 = NOT_FOUND) AND (programData = null))

------------------------------------------------------------------------
Test case ID: A_createGetEditGetDeleteGetProgram_Success

reset R1
ASSUME((uid -> p in U) AND (ADMIN in u.role))
(rcode1, t) := login(uid, p)
ASSERT(rcode1 = OK)

ASSUME(not_exists prog in Programs s.t. prog.name = progName)
(rcode2, progid) := createProgram(t, progName)
ASSERT(rcode2 = OK)
(rcode3, programData) := getProgram(t, progid)
ASSERT((rcode3 = OK) AND (programData.id = progid) AND (programData.name = progName))

newProgName := random.string
(rcode4, editedProgName) := editProgram(t, progid, newProgName)
ASSERT((rcode4 = OK) and (editedProgName = newProgName))
(rcode5, programDataUpdated) := getProgram(t, progid)
ASSERT((rcode5 = OK) AND (programDataUpdated.id = progid) AND (programDataUpdated.name = newProgName))

(rcode6) := deleteProgram(t, progid)
ASSERT(rcode6 = OK)
(rcode7, programDataDeleted) := getProgram(t, progid)
ASSERT((rcode7 = NOT_FOUND) AND (programDataDeleted = null))

------------------------------------------------------------------------
Test Case ID: A_FacultyEvaluateApplication_Success

------------------------------------------------------------------------
reset
ASSUME((uid -> p in U) AND (FACULTY in u.roles))
(rcode1, t) := login(uid, p)
ASSERT(rcode1 = OK)

(rcode2, apps) := getApplications(t)
ASSERT(rcode2 = OK)

appId := random.choice(apps).id
(rcode3) := assignApplication(t, appId, 'self') // This call will create a new record in E
ASSERT(rcode3 = OK)
(rcode4, appData) := getApplication(t, appId)
ASSERT(rcode4 = OK)  AND (appData.status = RELEASED_FOR_EVALUATION)

evaluationScore := random.int(0, 100)
(rcode3) := evaluateApplication(t, appId, evaluationScore)
ASSERT(rcode3 = OK)

------------------------------------------------------------------------
Test Case ID: A_FacultyReferApplication_Success
------------------------------------------------------------------------
reset
ASSUME((uid -> p in U) AND (FACULTY in u.roles))
(rcode1, t) := login(uid, p)
ASSERT(rcode1 = OK)

(rcode2, apps) := getApplications(t)
ASSERT(rcode2 = OK)

appId := random.choice(apps).id
uids := random.choice(F)
(rcode3) := referApplication(t, appId, uids)
ASSERT(rcode3 = OK)
------------------------------------------------------------------------
Test Case ID: A_createAndGetDomain_Success

reset
ASSUME(uid -> p in U) AND (ADMIN in u.roles)
(rcode1, t) := login(uid, p)
ASSERT(rcode1 = OK)

ASSUME(not_exists d in D s.t. d.name = domname)
(rcode2, domainid) := createDomain(t, progid, domname)
ASSERT(rcode2 = OK)

(rcode3, domainData) := getDomain(t, domainid)
ASSERT((rcode3 = OK) AND (domainData.id = domainid) and (domainData.name = domname))

------------------------------------------------------------------------
Test Case ID: A_editDomain_Success
reset
ASSUME(uid -> p in U) AND (ADMIN in u.roles) AND (exists d in D s.t. d.id = domainid)
(rcode1, t) := login(uid, p)
ASSERT(rcode1 = OK)

newDomName := random.string
(rcode2) := editDomain(t, domainid, newDomName)
ASSERT(rcode2 = OK)
------------------------------------------------------------------------
Test Case ID: A_deleteDomain_Success

reset
ASSUME(uid -> p in U) AND (ADMIN in u.roles) AND (exists d in D s.t. d.id = domainid)
(rcode1, t) := login(uid, p)
ASSERT(rcode1 = OK)

(rcode2) := deleteDomain(t, domainid)
ASSERT(rcode2 = OK)

------------------------------------------------------------------------
Test case ID: A_createEditGetDeleteDomain_Success
// Expect failure in last getDomain() call as the domain should no longer exist

reset
ASSUME(uid->p in U) AND (ADMIN in u.role)
(rcode1, t) := login(uid, p)
ASSERT(rcode1 = OK)

ASSUME(not_exists d in D s.t. d.name = domname)
(rcode2, domainid) := createDomain(t, progid, domname)
ASSERT(rcode2 = OK)

newdomname := random.string
(rcode3) := editDomain(t, domainid, newdomname)
ASSERT(rcode3 = OK)

(rcode4, data) := getDomain(t, domainid)
ASSERT((rcode4 = OK) AND (data.id = domainid) AND (data.name = newdomname))

(rcode5) := deleteDomain(t, domainid)
ASSERT(rcode5 = OK)

(rcode6, data) := getDomain(t, domainid)
ASSERT(rcode6 != OK) 

------------------------------------------------------------------------
Test case ID: A_createDeleteEditDomain_Failure
// Expect failure in last editDomain() call as the domain should no longer exist

reset
ASSUME(uid->p in U) AND (ADMIN in u.role)
(rcode1, t) := login(uid, p)
ASSERT(rcode1 = OK)

ASSUME(not_exists d in D s.t. d.name = domname)
(rcode2, domainid) := createDomain(t, progid, domname)
ASSERT(rcode2 = OK)

(rcode3) := deleteDomain(t, domainid)
ASSERT(rcode3 = OK)

newdomname := random.string
(rcode4) := editDomain(t, domainid, newdomname)
ASSERT(rcode4 != OK)

------------------------------------------------------------------------
Test case ID: A_createSubdomain_Success

reset
ASSUME(uid -> p in U) AND (ADMIN in u.roles)
(rcode1, t) := login(uid, p)
ASSERT(rcode1 = OK)

ASSUME(exists d in D s.t. d.id = domainId)
ASSUME(not_exists s in SD s.t. s.name = subdomainName)
(rcode2, subdomainId) := createSubdomain(t, domainId, subdomainName)
ASSERT(rcode2 = OK)
------------------------------------------------------------------------
Test case ID: A_getSubdomain_Success
reset
ASSUME(uid -> p in U)
(rcode1, t) := login(uid, p)
ASSERT(rcode1 = OK)

ASSUME(exists s in SD s.t. s.id = subdomainId)
(rcode2, data) := getSubdomain(t, subdomainId)
ASSERT((rcode2 = OK) AND (data.id = subdomainId))

------------------------------------------------------------------------
Test case ID: A_editSubdomain_Success
reset
ASSUME(uid -> p in U) AND (ADMIN in u.roles)
(rcode1, t) := login(uid, p)
ASSERT(rcode1 = OK)

ASSUME(exists s in SD s.t. s.id = subdomainId)
newSubdomainName := random.string
(rcode2) := editSubdomain(t, subdomainId, newSubdomainName)
ASSERT(rcode2 = OK)

------------------------------------------------------------------------
Test case ID: A_deleteSubdomain_Success
reset
ASSUME(uid -> p in U) AND (ADMIN in u.roles)
(rcode1, t) := login(uid, p)
ASSERT(rcode1 = OK)

ASSUME(exists s in SD s.t. s.id = subdomainId)
(rcode2) := deleteSubdomain(t, subdomainId)
ASSERT(rcode2 = OK)
------------------------------------------------------------------------
Test case ID: A_createAndGetSubdomain_Success
reset
ASSUME(uid -> p in U) AND (ADMIN in u.roles)
(rcode1, t) := login(uid, p)
ASSERT(rcode1 = OK)

ASSUME(exists d in D s.t. d.id = domainId)
ASSUME(not_exists s in SD s.t. s.name = subdomainName)
(rcode2, subdomainId) := createSubdomain(t, domainId, subdomainName)
ASSERT(rcode2 = OK)

(rcode3, data) := getSubdomain(t, subdomainId)
ASSERT((rcode3 = OK) AND (data.id = subdomainId) AND (data.name = subdomainName))

------------------------------------------------------------------------
Test case ID: A_editAndDeleteSubdomain_Success
// Last getDomain call should returns an error as it is trying to get a deleted subdomain

reset
ASSUME(uid -> p in U) AND (ADMIN in u.roles)
(rcode1, t) := login(uid, p)
ASSERT(rcode1 = OK)

ASSUME(exists s in SD s.t. s.id = subdomainId)
newSubdomainName := random.string
(rcode2) := editSubdomain(t, subdomainId, newSubdomainName)
ASSERT(rcode2 = OK)

(rcode3, data) := getSubdomain(t, subdomainId)
ASSERT((rcode3 = OK) and (data.name = newSubdomainName))

(rcode4) := deleteSubdomain(t, subdomainId)
ASSERT(rcode4 = OK)

(rcode5, data) := getSubdomain(t, subdomainId)
ASSERT(rcode5 != OK) 
------------------------------------------------------------------------
Test case ID: A_createSubdomain_Failure_DuplicateName
// Expecting an error because the subdomain name already exists

reset
ASSUME(uid -> p in U) AND (ADMIN in u.roles)
(rcode1, t) := login(uid, p)
ASSERT(rcode1 = OK)

ASSUME(exists d in D s.t. d.id = domainId)
ASSUME(exists s in SD s.t. s.name = subdomainName)
(rcode2, subdomainId) := createSubdomain(t, domainId, subdomainName)
ASSERT(rcode2 != OK)
------------------------------------------------------------------------
Test case ID: A_deleteNonExistentSubdomain_Failure
//Expecting an error because the subdomain doesn't exist

reset
ASSUME(uid -> p in U) AND (ADMIN in u.roles)
(rcode1, t) := login(uid, p)
ASSERT(rcode1 = OK)

ASSUME(not_exists s in SD s.t. s.id = subdomainId)
(rcode2) := deleteSubdomain(t, subdomainId)
ASSERT(rcode2 != OK) 
------------------------------------------------------------------------
Test case ID:
------------------------------------------------------------------------


CONCRETE TEST CASE
------------------------------------------------------------------------
Test case ID: C_createProgram_Success_1 (A_createProgram_Success)

reset
uid := "nikhilakn"
p := "nikhila"
(rcode1, t) := login(uid, p)
ASSERT(rcode1 = OK)
progname = 'someprog'
(rcode2, progid) := createProgram(t, progname)
ASSERT(rcode2 = OK)
------------------------------------------------------------------------
Test case ID: C_createProgram_Success_2 (A_createProgram_Success)
// Invalid credentials, login should fail

reset
uid := "nikhilakn"
p := "nikhila@123"
(rcode1, t) := login(uid, p)
ASSERT(rcode1 != OK)
------------------------------------------------------------------------
Test case ID: C_createProgram_Success_3 (A_createProgram_Success)
// User does not have admin role, createProgram should fail

reset
uid := "user1" 
p := "user1@123"
(rcode1, t) := login(uid, p)
ASSERT(rcode1 = OK)

progname := "someprog"
(rcode2, progid) := createProgram(t, progname)
ASSERT(rcode2 != OK) 

------------------------------------------------------------------------
Test case ID: C_createProgram_Success_4 (A_createProgram_Success)
// Program already exists, createProgram should fail

reset
uid := "nikhilakn"
p := "nikhila"
(rcode1, t) := login(uid, p)
ASSERT(rcode1 = OK)

ASSUME(exists prog in Programs s.t. prog.name = progName)
progName := "someprog"
(rcode2, progid) := createProgram(t, progName)
ASSERT(rcode2 != OK) 

------------------------------------------------------------------------

Test case ID: C_createGetProgram_Success_1 (A_createGetProgram_Success)

reset
uid := "nikhilakn"
p := "nikhila"
(rcode1, t) := login(uid, p)
ASSERT(rcode1 = OK)
progname = 'someprog'
(rcode2, progid) := createProgram(t, progname)
ASSERT(rcode2 = OK)
(rcode3, data) := getProgram(t, progid)
ASSERT((rcode3 = OK) AND (data.id = progid) AND (data.name = progname))
------------------------------------------------------------------------

Test case ID: C_createProgramAndEdit_Success_1 (A_createProgramAndEdit_Success)

reset
uid := "admin"
p := "admin@123"
(rcode1, t) := login(uid, p)
ASSERT(rcode1 = OK)
progName := "someProgram"
(rcode2, progid) := createProgram(t, progName)
ASSERT(rcode2 = OK)
newProgName := "newProgram"
(rcode3, editedProgName) := editProgram(t, progid, newProgName)
ASSERT((rcode3 = OK) and (editedProgName = newProgName))
(rcode4, programData) := getProgram(t, progid)
ASSERT((rcode4 = OK) AND (programData.id = progid) AND (programData.name = newProgName))

------------------------------------------------------------------------
Test case ID: C_createProgramAndEdit_Failed_2 (A_createProgramAndEdit_Success)
//Program already exists, editProgram should fail

reset
uid := "admin"
p := "admin@123"
(rcode1, t) := login(uid, p)
ASSERT(rcode1 = OK)
progName := "someProgram"
(rcode2, progid) := createProgram(t, progName)
ASSERT(rcode2 = OK)
newProgName := "existingProgram"
(rcode3, editedProgName) := editProgram(t, progid, newProgName)
ASSERT((rcode3 != OK)
(rcode4, programData) := getProgram(t, progid)
ASSERT((rcode4 = OK) AND (programData.id = progid) AND (programData.name = progName))

------------------------------------------------------------------------
Test case ID: C_createProgramAndDelete_Success_1 (A_createProgramAndDelete_Success)

reset
uid := "admin"
p := "admin@123"
(rcode1, t) := login(uid, p)
ASSERT(rcode1 = OK)
progName := "someProgram"
(rcode2, progid) := createProgram(t, progName)
ASSERT(rcode2 = OK)
(rcode3) := deleteProgram(t, progid)
ASSERT(rcode3 = OK)
(rcode4, programData) := getProgram(t, progid)
ASSERT((rcode4 = NOT_FOUND) AND (programData = null))
------------------------------------------------------------------------

Test case ID: C_createGetEditGetDeleteGetProgram_Success_1 (A_createGetEditGetDeleteGetProgram_Success)


reset
uid := "admin"
p := "admin@123"
(rcode1, t) := login(uid, p)
ASSERT(rcode1 = OK)

progName := "firstProgram"
(rcode2, progid) := createProgram(t, progName)
ASSERT(rcode2 = OK)
(rcode3, programData) := getProgram(t, progid)
ASSERT((rcode3 = OK) AND (programData.id = progid) AND (programData.name = progName))

newProgName := "updatedProgram"
(rcode4, editedProgName) := editProgram(t, progid, newProgName)
ASSERT((rcode4 = OK) AND (editedProgName = newProgName))
(rcode5, programDataUpdated) := getProgram(t, progid)
ASSERT((rcode5 = OK) AND (programDataUpdated.id = progid) AND (programDataUpdated.name = newProgName))

(rcode6) := deleteProgram(t, progid)
ASSERT(rcode6 = OK)
(rcode7, programDataDeleted) := getProgram(t, progid)
ASSERT((rcode7 = NOT_FOUND) AND (programDataDeleted = null))

------------------------------------------------------------------------
Test case ID: C_FacultyReferApplication_Success_1(A_FacultyReferApplication_Success)

reset
uid := "faculty1"
p := "faculty1@123"
(rcode1, t) := login(uid, p)
ASSERT(rcode1 = OK)

(rcode2, apps) := getApplications(t)
ASSERT(rcode2 = OK)

appId := random.choice(apps).id
uid' := "faculty2"
Uid'' := "faculty3"
(rcode3) := referApplication(t, appId, [uid', uid''])
ASSERT(rcode3 = OK)
------------------------------------------------------------------------
Test case ID: C_FacultyReferApplication_Fail_2(A_FacultyReferApplication_Success)
// Refer should fail because the user does not exist or is not a faculty member

reset
uid := "faculty1"
p := "faculty1@123"
(rcode1, t) := login(uid, p)
ASSERT(rcode1 = OK)

(rcode2, apps) := getApplications(t)
ASSERT(rcode2 = OK)

appId := random.choice(apps).id
uid'="notafaculty"
(rcode3) := referApplication(t, appId, [uid'])
ASSERT(rcode3 != OK) 

------------------------------------------------------------------------
Test case ID: C_FacultyReferApplication_Fail_3(A_FacultyReferApplication_Success)
// Refer should fail because the application does not exist

reset
uid := "faculty1"
p := "faculty1@123"
(rcode1, t) := login(uid, p)
ASSERT(rcode1 = OK)

(rcode2, apps) := getApplications(t)
ASSERT(rcode2 = OK)


appId := "someappId" // appId not in Applications
uid' := "faculty2"
(rcode3) := referApplication(t, appId, [uid'])
ASSERT(rcode3 != OK) 

------------------------------------------------------------------------
Test Case ID: C_createAndGetDomain_Success1 (A_createAndGetDomain_Success)

reset
uid := "admin"
p := "admin@123"
(rcode1, t) := login(uid, p)
ASSERT(rcode1 = OK)

progid := "prog001"
domname := "somedomain"
(rcode2, domainid) := createDomain(t, progid, domname)
ASSERT(rcode2 = OK)

(rcode3, data) := getDomain(t, domainid)
ASSERT((rcode3 = OK) AND (data.id = domainid) AND (data.name = domname))
------------------------------------------------------------------------
Test Case ID: C_editDomain_Success1 (A_editDomain_Success)

reset
uid := "admin"
p := "admin@123"
(rcode1, t) := login(uid, p)
ASSERT(rcode1 = OK)

domainid := "domain123"
newDomName := "newdomainname"
(rcode2) := editDomain(t, domainid, newDomName)
ASSERT(rcode2 = OK)
(rcode3, data) := getDomain(t, domainid)
ASSERT((rcode3 = OK) AND (data.id = domainid) AND (data.name = newDomName))
------------------------------------------------------------------------
Test Case ID: C_deleteDomain_Success1 (A_deleteDomain_Success)

reset
uid := "admin"
p := "admin@123"
(rcode1, t) := login(uid, p)
ASSERT(rcode1 = OK)

domainid := "domain123"
(rcode2) := deleteDomain(t, domainid)
ASSERT(rcode2 = OK)
------------------------------------------------------------------------
Test case ID: C_createEditGetDeleteDomain_Success1 (A_createEditGetDeleteDomain_Success)

reset
uid := “admin”
p := “admin@123”
(rcode1, t) := login(uid, p)
ASSERT(rcode1 = OK)

progid := “prog001”
domname := “somedomain”
(rcode2, domainid) := createDomain(t, progid, domname)
ASSERT(rcode2 = OK)

newdomname := “newdomainname”
(rcode3) := editDomain(t, domainid, newdomname)
ASSERT(rcode3 = OK)

(rcode4, data) := getDomain(t, domainid)
ASSERT((rcode4 = OK) AND (data.id = domainid) AND (data.name = newdomname))

(rcode5) := deleteDomain(t, domainid)
ASSERT(rcode5 = OK)

(rcode6, data) := getDomain(t, domainid)
ASSERT(rcode6 != OK)
------------------------------------------------------------------------
Test case ID: C_createDeleteEditDomain_Failure1(A_createDeleteEditDomain_Failure)

reset
uid := “admin”
p := “admin@123”
(rcode1, t) := login(uid, p)
ASSERT(rcode1 = OK)

progid := “prog001”
domname := “somedomain”
(rcode2, domainid) := createDomain(t, progid, domname)
ASSERT(rcode2 = OK)

(rcode3) := deleteDomain(t, domainid)
ASSERT(rcode3 = OK)

newdomname := “newdomainname”
(rcode4) := editDomain(t, domainid, newdomname)
ASSERT(rcode4 != OK)
------------------------------------------------------------------------
Test case ID: C_createAndGetSubdomain_Success_1(A_createAndGetSubdomain_Success)

reset
uid := "admin"
p := "admin@123"
(rcode1, t) := login(uid, p)
ASSERT(rcode1 = OK)

domainId := "domain123"
subdomainName := "newSubdomain"
(rcode2, subdomainId) := createSubdomain(t, domainId, subdomainName)
ASSERT(rcode2 = OK)

(rcode3, data) := getSubdomain(t, subdomainId)
ASSERT((rcode3 = OK) and (data.id = subdomainId) and (data.name = subdomainName))
------------------------------------------------------------------------
Test case ID: C_editAndDeleteSubdomain_Success_1(A_editAndDeleteSubdomain_Success)

reset
uid := "admin"
p := "admin@123"
(rcode1, t) := login(uid, p)
ASSERT(rcode1 = OK)

subdomainId := "sub123"
newSubdomainName := "updatedSubdomain"
(rcode2) := editSubdomain(t, subdomainId, newSubdomainName)
ASSERT(rcode2 = OK)

(rcode3, data) := getSubdomain(t, subdomainId)
ASSERT((rcode3 = OK) and (data.name = newSubdomainName))

(rcode4) := deleteSubdomain(t, subdomainId)
ASSERT(rcode4 = OK)

(rcode5, data) := getSubdomain(t, subdomainId)
ASSERT(rcode5 != OK)

------------------------------------------------------------------------
Test case ID: C_createSubdomain_Failure_DuplicateName_1(A_createSubdomain_Failure_DuplicateName)

reset
uid := "admin"
p := "admin@123"
(rcode1, t) := login(uid, p)
ASSERT(rcode1 = OK)

domainId := "domain123"
subdomainName := "existingSubdomain"
(rcode2, subdomainId) := createSubdomain(t, domainId, subdomainName)
ASSERT(rcode2 != OK)
------------------------------------------------------------------------
Test case ID: C_deleteNonExistentSubdomain_Failure_1(A_deleteNonExistentSubdomain_Failure)

reset
uid := "admin"
p := "admin@123"
(rcode1, t) := login(uid, p)
ASSERT(rcode1 = OK)

subdomainId := "notinSubdomain"
(rcode2) := deleteSubdomain(t, subdomainId)
ASSERT(rcode2 != OK)
------------------------------------------------------------------------
Test case ID: 
------------------------------------------------------------------------



