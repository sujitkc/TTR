API SPECIFICATION
-----------------
GLOBAL DATA
-----------------
type Role = ADMIN | CANDIDATE | OFFICE | FACULTY | COMMITTEE | DOMAIN_REPRESENTATIVE
type Program { id : string, name : string }
type Application_status = VERIFICATION_PENDING|VERIFICATION_COMPLETED|REVIEW_PENDING|REVIEW_COMPLETED|SHORTLISTED|OFFERED|REFERED
type Application { id: string, programId: string, domainId: string, subDomainId: string, status: Application_status }

type USERDATA{password: string, Applications: Application set, roles: Role set}

PermittedRoleCombinations : Role set set =
{
	{ ADMIN, FACULTY, DOMAIN_REP, COMITTEE },
⁠	{ CANDIDATE, OFFICE, ADMIN },
⁠	{ CANDIDATE },
}


U : (string -> string) map // Users
C : set of all u in U, s.t u.role = CANDIDATE
L : string set // Logged in users
T : (Token -> string) map // Tokens
P : Program set // Set of Programs
A : (C -> Application) map // Applications



Exists R in PermittedRoleCombinations | For all u in U, u.roles is subset of R
------------------------------------APIs------------------------------------
signup: string * string ==> HTTPRESPONSECODE
login:  string * string ==> (HTTPRESPONSECODE * token)

// Program APIs
createProgram: Token * string ==> (HTTPRESPONSECODE * string)
getProgram: Token * string ==> (HTTPRESPONSECODE * string)
editProgram: Token * string ==> (HTTPRESPONSECODE * string)
deleteProgram: Token * string ==> (HTTPRESPONSECODE)

// Application APIs
submitApplication: Token * string ==> (HTTPRESPONSECODE * string)
verifyApplication: Token * string ==> (HTTPRESPONSECODE)
getApplications: Token ==> (HTTPRESPONSECODE * Application set)
selectOrReferApplication: Token * string * string ==>(HTTPRESPONSECODE)
evaluateApplication: Token * string * map ==> (HTTPRESPONSECODE)
------------------------------------------------------------------------

---------------------------------INITIALISATION-----------------------------
INIT:
U = {}
L = {}
T = {}
P = {}
A = {}
------------------------------------------------------------------------

---------------------------------SIGNUP_OK-----------------------------------
PRECONDITION: U[uid] = NIL
signup(uid : string, p : string) ==> (OK)
POSTCONDITION: U' = U[uid -> p]
------------------------------------------------------------------------

---------------------------------LOGIN_OK-----------------------------------
PRECONDITION: U[uid] = p
login(uid : string, p : string) ==> (OK, t : token)
POSTCONDITION: T' = T[t -> uid] and L' = L union {uid}
------------------------------------------------------------------------

-------------------------------CREATEPROGRAM_OK-----------------------------
PRECONDITION: 
(t -> u in T and u in U) AND (ADMIN in u.role) AND
(not_exists p in P s.t. p.name = programName)


createProgram(t : Token, programName : string) ==> (OK, id : string)

POSTCONDITION: P' = P union Program{id, programName}
------------------------------------------------------------------------
———————————————GETPROGRAM_OK-----------------------------
PRECONDITION: 
(t -> u in T and u in U) AND (ADMIN in u.role) AND
( p in P s.t.  programId = p.id)


getProgram(t : Token, programName : string) ==> (OK, programData: Program)

POSTCONDITION: programId = programData.id
------------------------------------------------------------------------
———————————————UPDATEPROGRAM_OK-----------------------------
PRECONDITION: 
(t -> u in T and u in U) AND (ADMIN in u.role) AND
( p in P s.t.  programId = p.id) AND p.name = newProgramName


updateProgram(t : Token, newProgramName: string) ==> (OK, id : string)

POSTCONDITION: P' = P union Program{id, newprogramName}
------------------------------------------------------------------------

———————————————SUBMITAPPLICATION_OK-----------------------------
PRECONDITION: (t -> u in T AND u in U) AND (CANDIDATE in u.roles) AND
(not_exists app' in A[u] s.t. (app.domainId = app'.domainId AND app.subDomainId = app'.subDomainId AND app.programId = app'.programId))
submitApplication(t : Token, app : Application) ==> (OK, id: string)
POSTCONDITION: A' = A union Application{id, app.domainId, app.subDomainId, app.programId} 

------------------------------------------------------------------------
ABSTRACT TEST CASE
------------------------------------------------------------------------
Test case ID: A_createProgram_Success

reset
ASSUME((uid->p in U) AND (ADMIN in u.role)) // assuming U is a map: string --> string
(rcode1, t) := login(uid, p)
ASSERT(rcode1 = OK)

ASSUME(not_exists prog in Programs s.t. prog.name = progname)
(rcode2, progid) := createProgram(t, progname)
ASSERT(rcode2 = OK)
------------------------------------------------------------------------
Test case ID: A_createAndGetProgram_Success


reset
ASSUME(uid->p in U) AND (ADMIN in u.role)) // assuming U is a map: string --> string
(rcode1, t) := login(uid, p)
ASSERT(rcode1 = OK)

ASSUME(not_exists prog in Programs s.t. prog.name = progname)
(rcode2, progid) := createProgram(t, progname)
ASSERT(rcode2 = OK)
(rcode3, data) := getProgram(t, progid)
ASSERT((rcode3 = OK) and (data.id = progid) and (data.name = progname))
------------------------------------------------------------------------
Test case ID: A_createProgramAndEdit_Success

reset
ASSUME((uid -> p in U) AND (ADMIN in u.role))
(rcode1, t) := login(uid, p)
ASSERT(rcode1 = OK)

ASSUME(not_exists prog in Programs s.t. prog.name = progName)
(rcode2, progid) := createProgram(t, progName)
ASSERT(rcode2 = OK)
newProgName := random.string
(rcode3, editedProgName) := editProgram(t, progid, newProgName)
ASSERT((rcode3 = OK) AND (editedProgName = newProgName))
(rcode4, programData) := getProgram(t, progid)
ASSERT((rcode4 = OK) AND (programData.id = progid) AND (programData.name = newProgName))

------------------------------------------------------------------------
Test case ID: A_createProgramAndDelete_Success

reset
ASSUME((uid -> p in U) AND (ADMIN in u.role))
(rcode1, t) := login(uid, p)
ASSERT(rcode1 = OK)

ASSUME(not_exists prog in Programs s.t. prog.name = progName)
(rcode2, progid) := createProgram(t, progName)
ASSERT(rcode2 = OK)
(rcode3) := deleteProgram(t, progid)
ASSERT(rcode3 = OK)
(rcode4, programData) := getProgram(t, progid)
ASSERT((rcode4 = NOT_FOUND) AND (programData = null))

------------------------------------------------------------------------
Test case ID: A_createGetEditGetDeleteGetProgram_Success

reset
ASSUME((uid -> p in U) AND (ADMIN in u.role))
(rcode1, t) := login(uid, p)
ASSERT(rcode1 = OK)

ASSUME(not_exists prog in Programs s.t. prog.name = progName)
(rcode2, progid) := createProgram(t, progName)
ASSERT(rcode2 = OK)
(rcode3, programData) := getProgram(t, progid)
ASSERT((rcode3 = OK) AND (programData.id = progid) AND (programData.name = progName))

newProgName := random.string
(rcode4, editedProgName) := editProgram(t, progid, newProgName)
ASSERT((rcode4 = OK) and (editedProgName = newProgName))
(rcode5, programDataUpdated) := getProgram(t, progid)
ASSERT((rcode5 = OK) AND (programDataUpdated.id = progid) AND (programDataUpdated.name = newProgName))

(rcode6) := deleteProgram(t, progid)
ASSERT(rcode6 = OK)
(rcode7, programDataDeleted) := getProgram(t, progid)
ASSERT((rcode7 = NOT_FOUND) AND (programDataDeleted = null))

------------------------------------------------------------------------
Test Case ID: A_FacultyReviewApplication_Success

------------------------------------------------------------------------
reset
ASSUME((uid -> p in U) AND (FACULTY in u.roles))
(rcode1, t) := login(uid, p)
ASSERT(rcode1 = OK)

(rcode2, apps) := getApplications(t)
ASSERT(rcode2 = OK)

appId := random.choice(apps).id
(rcode3) := reviewApplication(t, appId, 'self') //Need to complete. Now app.status is not updated.
ASSERT(rcode3 = OK)
(rcode4, appData) := getApplication(t, appId)
ASSERT(rcode4 = OK)  AND (appData.status = REVIEW_COMPLETED)

evaluationData := // Need to define the type of evaluation data
(rcode3) := evaluateApplication(t, appId, evaluationData)
ASSERT(rcode3 = OK)

------------------------------------------------------------------------
Test Case ID: A_FacultyReferApplication_Success
------------------------------------------------------------------------
reset
ASSUME((uid -> p in U) AND (FACULTY in u.roles))
(rcode1, t) := login(uid, p)
ASSERT(rcode1 = OK)

(rcode2, apps) := getApplications(t)
ASSERT(rcode2 = OK)

appId := random.choice(apps).id
ASSUME((uid' in U) AND (FACULTY in u'.roles) // List of IDs are possible
(rcode3) := referApplication(t, appId, [uid'])
ASSERT(rcode3 = OK)
------------------------------------------------------------------------

CONCRETE TEST CASE
------------------------------------------------------------------------
Test case ID: C_createProgram_Success_1 (A_createProgram_Success)

reset
uid := "nikhilakn"
p := "nikhila"
(rcode1, t) := login(uid, p)
ASSERT(rcode1 = OK)
progname = 'someprog'
(rcode2, progid) := createProgram(t, progname)
ASSERT(rcode2 = OK)
------------------------------------------------------------------------
Test case ID: C_createProgram_Success_2 (A_createProgram_Success)
// Invalid credentials, login should fail

reset
uid := "nikhilakn"
p := "nikhila@123"
(rcode1, t) := login(uid, p)
ASSERT(rcode1 != OK)
------------------------------------------------------------------------
Test case ID: C_createProgram_Success_3 (A_createProgram_Success)
// User does not have admin role, createProgram should fail

reset
uid := "user1" 
p := "user1@123"
(rcode1, t) := login(uid, p)
ASSERT(rcode1 = OK)

progname := "someprog"
(rcode2, progid) := createProgram(t, progname)
ASSERT(rcode2 != OK) 

------------------------------------------------------------------------
Test case ID: C_createProgram_Success_4 (A_createProgram_Success)
// Program already exists, createProgram should fail

reset
uid := "nikhilakn"
p := "nikhila"
(rcode1, t) := login(uid, p)
ASSERT(rcode1 = OK)

ASSUME(exists prog in Programs s.t. prog.name = progName)
progName := "someprog"
(rcode2, progid) := createProgram(t, progName)
ASSERT(rcode2 != OK) 

------------------------------------------------------------------------

Test case ID: C_createGetProgram_Success_1 (A_createGetProgram_Success)

reset
uid := "nikhilakn"
p := "nikhila"
(rcode1, t) := login(uid, p)
ASSERT(rcode1 = OK)
progname = 'someprog'
(rcode2, progid) := createProgram(t, progname)
ASSERT(rcode2 = OK)
(rcode3, data) := getProgram(t, progid)
ASSERT((rcode3 = OK) AND (data.id = progid) AND (data.name = progname))
------------------------------------------------------------------------

Test case ID: C_createProgramAndEdit_Success_1 (A_createProgramAndEdit_Success)

reset
uid := "admin"
p := "admin@123"
(rcode1, t) := login(uid, p)
ASSERT(rcode1 = OK)
progName := "someProgram"
(rcode2, progid) := createProgram(t, progName)
ASSERT(rcode2 = OK)
newProgName := "newProgram"
(rcode3, editedProgName) := editProgram(t, progid, newProgName)
ASSERT((rcode3 = OK) and (editedProgName = newProgName))
(rcode4, programData) := getProgram(t, progid)
ASSERT((rcode4 = OK) AND (programData.id = progid) AND (programData.name = newProgName))

------------------------------------------------------------------------
Test case ID: C_createProgramAndEdit_Failed_2 (A_createProgramAndEdit_Success)
//Program already exists, editProgram should fail

reset
uid := "admin"
p := "admin@123"
(rcode1, t) := login(uid, p)
ASSERT(rcode1 = OK)
progName := "someProgram"
(rcode2, progid) := createProgram(t, progName)
ASSERT(rcode2 = OK)
newProgName := "existingProgram"
(rcode3, editedProgName) := editProgram(t, progid, newProgName)
ASSERT((rcode3 != OK)
(rcode4, programData) := getProgram(t, progid)
ASSERT((rcode4 = OK) AND (programData.id = progid) AND (programData.name = progName))

------------------------------------------------------------------------
Test case ID: C_createProgramAndDelete_Success_1 (A_createProgramAndDelete_Success)

reset
uid := "admin"
p := "admin@123"
(rcode1, t) := login(uid, p)
ASSERT(rcode1 = OK)
progName := "someProgram"
(rcode2, progid) := createProgram(t, progName)
ASSERT(rcode2 = OK)
(rcode3) := deleteProgram(t, progid)
ASSERT(rcode3 = OK)
(rcode4, programData) := getProgram(t, progid)
ASSERT((rcode4 = NOT_FOUND) AND (programData = null))
------------------------------------------------------------------------

Test case ID: C_createGetEditGetDeleteGetProgram_Success_1 (A_createGetEditGetDeleteGetProgram_Success)


reset
uid := "admin"
p := "admin@123"
(rcode1, t) := login(uid, p)
ASSERT(rcode1 = OK)

progName := "firstProgram"
(rcode2, progid) := createProgram(t, progName)
ASSERT(rcode2 = OK)
(rcode3, programData) := getProgram(t, progid)
ASSERT((rcode3 = OK) AND (programData.id = progid) AND (programData.name = progName))

newProgName := "updatedProgram"
(rcode4, editedProgName) := editProgram(t, progid, newProgName)
ASSERT((rcode4 = OK) AND (editedProgName = newProgName))
(rcode5, programDataUpdated) := getProgram(t, progid)
ASSERT((rcode5 = OK) AND (programDataUpdated.id = progid) AND (programDataUpdated.name = newProgName))

(rcode6) := deleteProgram(t, progid)
ASSERT(rcode6 = OK)
(rcode7, programDataDeleted) := getProgram(t, progid)
ASSERT((rcode7 = NOT_FOUND) AND (programDataDeleted = null))

------------------------------------------------------------------------
Test case ID: C_FacultyReferApplication_Success_1(A_FacultyReferApplication_Success)

reset
uid := "faculty1"
p := "faculty1@123"
(rcode1, t) := login(uid, p)
ASSERT(rcode1 = OK)

(rcode2, apps) := getApplications(t)
ASSERT(rcode2 = OK)

appId := random.choice(apps).id
uid' := "faculty2"
Uid'' := "faculty3"
(rcode3) := referApplication(t, appId, [uid', uid''])
ASSERT(rcode3 = OK)
------------------------------------------------------------------------
Test case ID: C_FacultyReferApplication_Fail_2(A_FacultyReferApplication_Success)
// Refer should fail because the user does not exist or is not a faculty member

reset
uid := "faculty1"
p := "faculty1@123"
(rcode1, t) := login(uid, p)
ASSERT(rcode1 = OK)

(rcode2, apps) := getApplications(t)
ASSERT(rcode2 = OK)

appId := random.choice(apps).id
uid'="notafaculty"
(rcode3) := referApplication(t, appId, [uid'])
ASSERT(rcode3 != OK) 

------------------------------------------------------------------------
Test case ID: C_FacultyReferApplication_Fail_3(A_FacultyReferApplication_Success)
// Refer should fail because the application does not exist

reset
uid := "faculty1"
p := "faculty1@123"
(rcode1, t) := login(uid, p)
ASSERT(rcode1 = OK)

(rcode2, apps) := getApplications(t)
ASSERT(rcode2 = OK)


appId := "someappId" // appId not in Applications
uid' := "faculty2"
(rcode3) := referApplication(t, appId, [uid'])
ASSERT(rcode3 != OK) 

